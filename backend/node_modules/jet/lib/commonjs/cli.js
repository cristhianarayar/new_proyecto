"use strict";

var _nodeFs = _interopRequireDefault(require("node:fs"));
var _nodePath = require("node:path");
var _yargs = _interopRequireDefault(require("yargs"));
var _helpers = require("yargs/helpers");
var _zod = require("zod");
var _istanbulLibCoverage = require("istanbul-lib-coverage");
var _mochaRemoteServer = require("mocha-remote-server");
var _cosmiconfig = require("cosmiconfig");
var _types = require("./types");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const coverageMap = (0, _istanbulLibCoverage.createCoverageMap)({});
const jetPackageJsonPath = (0, _nodePath.resolve)(__dirname, '../../package.json');
const jetPackageJson = JSON.parse(_nodeFs.default.readFileSync(jetPackageJsonPath, 'utf8'));
const JetBeforeHook = _zod.z.function().args(_types.JetConfigSchema).returns(_zod.z.union([_zod.z.promise(_types.JetConfigSchema), _types.JetConfigSchema]));
const JetAfterHook = _zod.z.function().args(_types.JetConfigSchema).returns(_zod.z.union([_zod.z.promise(_zod.z.undefined()), _zod.z.undefined()])).optional();
const JetRcSchema = _zod.z.object({
  config: _types.JetConfigSchema,
  targets: _zod.z.record(_zod.z.object({
    config: _types.JetConfigSchema,
    before: JetBeforeHook,
    after: JetAfterHook
  }))
});
async function isMetroRunning(port = 8081) {
  try {
    const fetchResult = await fetch(`http://localhost:${port}/status`);
    const status = await fetchResult.text();
    return status.includes('packager-status:running');
  } catch (e) {
    return false;
  }
}
function isNumeric(value) {
  return /^-?\d+$/.test(value);
}
function coerceValue(value) {
  if (value.toLowerCase() === 'false') {
    return false;
  } else if (value.toLowerCase() === 'true') {
    return true;
  } else if (isNumeric(value)) {
    return parseFloat(value);
  } else {
    return value;
  }
}
function parseKeyValues(opts) {
  const pairs = opts.map(value => value.split(',')).flat();
  const splitPairs = pairs.map(pair => {
    const [key, value] = pair.split('=');
    if (typeof value === 'string' && value.length > 0) {
      return [key, coerceValue(value)];
    } else {
      return [key, true];
    }
  }).filter(([k]) => k !== '');
  return Object.fromEntries(splitPairs);
}
const cleanupTasks = new Set();
let cleanedUp = false;
function cleanup() {
  if (cleanedUp) {
    return;
  }
  cleanedUp = true;
  const tasks = [...cleanupTasks];
  cleanupTasks.clear();
  tasks.reduce((previous, task) => previous.then(task), Promise.resolve()).catch(err => {
    console.log(`[游린] Failed to run a cleanup task: ${err.message}`);
  });
}
async function startServer(server, config, after) {
  server.on('started', server => {
    const url = server.url;
    console.log(`[游릴] Jet remote server listening at "${url}".`);
  });
  server.on('connection', (_, req) => {
    console.log(`[游릴] Jet client connected from "${req.socket.remoteAddress + ':' + req.socket.remotePort}".`);
  });
  server.on('disconnection', (_, code, reason) => {
    const print = code === 1000 ? console.log : console.warn;
    const msg = code === 1000 ? 'normal closure' : reason || 'for no particular reason';
    print(`[游릳] Jet client disconnected - ${msg} (code = ${code}).`);
    if (code !== 1000 && config.exitOnError) {
      print(`[游린] Exiting after an abnormal disconnect.`);
      process.exitCode = 1;
      cleanup();
    }
  });
  server.on('error', error => {
    if (error instanceof _mochaRemoteServer.ClientError) {
      console.error(`[游린] ${error.message || 'Missing a message'}`);
    } else {
      console.error(`[游린] ${error.message || 'Missing a message'}`);
    }
    if (config.exitOnError) {
      process.exitCode = 1;
      cleanup();
    }
  });
  cleanupTasks.add(async () => {
    if (server.listening) {
      await server.stop();
      console.log('[游빛] Stopped the server');
    }
  });
  await server.start();
  const runAfterHook = async () => {
    console.log('[游뿧] Running after hook...');
    await after?.(config);
  };
  cleanupTasks.add(runAfterHook);
  process.on('SIGINT', cleanup);
  process.on('exit', cleanup);
}
function attachHttpServer(wss) {
  const server = wss._server;
  if (!server) {
    console.error('No underlying server found in WebSocket server');
    return;
  }
  server.on('request', (req, res) => {
    if (req.url === '/coverage' && req.method === 'POST') {
      let body = '';
      req.on('data', chunk => {
        body += chunk.toString();
      });
      req.on('end', () => {
        try {
          coverageMap.merge(JSON.parse(body));
          global.__coverage__ = coverageMap.toJSON();
          res.end(JSON.stringify({
            message: 'OK'
          }));
        } catch (e) {
          res.end(JSON.stringify({
            error: 'Invalid JSON'
          }));
        }
      });
    } else {
      res.writeHead(404, {
        'Content-Type': 'application/json'
      });
      res.end(JSON.stringify({
        error: 'Not Found'
      }));
    }
  });
}
(0, _yargs.default)((0, _helpers.hideBin)(process.argv)).scriptName('jet').version('version', 'Show version number & exit', jetPackageJson.version).alias('v', 'version').option('target', {
  description: 'The name of the test target to run as defined in your "jet" package.json config.',
  type: 'string',
  demandOption: true,
  alias: 'T'
}).option('grep', {
  description: 'Only run tests matching this string or regexp',
  type: 'string',
  default: process.env.JET_REMOTE_GREP,
  alias: 'g'
}).option('coverage', {
  description: 'Run tests with coverage enabled.',
  type: 'boolean',
  default: process.env.JET_COVERAGE === 'true',
  alias: 'C'
}).option('invert', {
  description: 'Inverts --grep matches',
  type: 'boolean',
  default: process.env.JET_REMOTE_INVERT === 'true',
  alias: 'i'
}).option('context', {
  description: 'Runtime context sent to client when starting a run (<k=v,[k1=v1,..]>)',
  type: 'array',
  alias: 'c',
  default: process.env.JET_REMOTE_CONTEXT || [],
  coerce: parseKeyValues
}).option('watch', {
  description: 'Keep the server running after a test has ended',
  type: 'boolean',
  default: process.env.JET_REMOTE_WATCH === 'true' || false,
  alias: 'w'
}).option('slow', {
  type: 'number',
  alias: 's',
  description: 'Specify "slow" test threshold (in milliseconds)',
  default: parseInt(process.env.JET_REMOTE_SLOW || '2000', 10)
}).option('hostname', {
  description: 'Network hostname to use when listening for clients',
  default: process.env.JET_REMOTE_HOSTNAME || '0.0.0.0',
  alias: 'H'
}).option('metro-port', {
  description: 'Network port that Metro is running on.',
  default: parseInt(process.env.JET_METRO_PORT || '8081', 10),
  alias: 'M'
}).option('port', {
  description: 'Network port to use when listening for clients',
  default: parseInt(process.env.JET_REMOTE_PORT || '8090', 10),
  alias: 'P'
}).option('timeout', {
  type: 'number',
  alias: ['t', 'timeouts'],
  description: 'Specify test timeout threshold (in milliseconds)',
  default: parseInt(process.env.JET_REMOTE_TIMEOUT || '30000', 10)
}).option('exit-on-error', {
  type: 'boolean',
  description: 'Exit immediately if an error occurs',
  alias: 'e',
  default: process.env.JET_REMOTE_EXIT_ON_ERROR === 'true'
}).option('reporter-option', {
  description: 'Reporter-specific options (<k=v,[k1=v1,..]>)',
  type: 'array',
  default: process.env.JET_REMOTE_REPORTER_OPTIONS || [],
  coerce: parseKeyValues,
  alias: ['O', 'reporter-options']
}).option('reporter', {
  description: 'Specify reporter to use',
  alias: 'R',
  default: process.env.JET_REMOTE_REPORTER || 'spec'
}).option('context', {
  description: 'Runtime context sent to client when starting a run (<k=v,[k1=v1,..]>)',
  type: 'array',
  alias: 'c',
  default: process.env.JET_REMOTE_CONTEXT || [],
  coerce(opts) {
    const pairs = opts.map(value => value.split(',')).flat();
    const splitPairs = pairs.map(pair => {
      const [key, value] = pair.split('=');
      if (typeof value === 'string' && value.length > 0) {
        return [key, coerceValue(value)];
      } else {
        return [key, true];
      }
    }).filter(([k]) => k !== '');
    return Object.fromEntries(splitPairs);
  }
}).command('$0 [command...]', 'Start Jet tests.', () => {}, async argv => {
  const explorer = (0, _cosmiconfig.cosmiconfig)('jet');
  try {
    var result = await explorer.search();
    if (!result) {
      throw new Error('No configuration found');
    }
    console.log(`[游릴] Loaded 'jet' configuration from ${result.filepath}`);
  } catch (error) {
    console.log("[游린] Could not find a 'jet' configuration file.");
    process.exit(1);
  }
  const cliConfig = _types.JetConfigSchema.parse(argv);
  const jetRc = JetRcSchema.parse(result.config);
  const jetRcGlobalConfig = jetRc.config ?? {};
  const target = jetRc.targets[argv.target];
  if (!target) {
    console.log(`[游린] Target "${argv.target}" not found in your Jet config.`);
    process.exit(1);
  }
  const targetConfig = target.config ?? {};
  const contextMerged = {
    ...(cliConfig.context ?? {}),
    ...(jetRcGlobalConfig.context ?? {}),
    ...(targetConfig.context ?? {})
  };
  const reporterOptionsMerged = {
    ...(cliConfig.reporterOptions ?? {}),
    ...(jetRcGlobalConfig.reporterOptions ?? {}),
    ...(targetConfig.reporterOptions ?? {})
  };
  const mergedConfig = {
    ...cliConfig,
    ...jetRcGlobalConfig,
    ...targetConfig,
    context: contextMerged,
    reporterOptions: reporterOptionsMerged
  };
  console.log(mergedConfig);
  console.log('[游] Starting tests...');
  console.log('[游빞] Filter (--grep):', argv.grep || 'none');
  console.log('[游댃] Invert filters:', argv.invert);
  if (!(await isMetroRunning(argv.metroPort))) {
    console.warn(`[游릳] Metro is not running (${argv.metroPort} via '--metro-port' flag.). Start it before tests to enable stack trace symbolication.`);
  }
  console.log('[游뿧] Running before hook...');
  const beforeHookReturnedConfig = await target.before?.(mergedConfig);
  if (!beforeHookReturnedConfig) {
    console.log(`[游린] Before hook on target "${argv.target}" must return a config object.`);
    process.exit(1);
  }
  const finalConfig = _types.JetConfigSchema.parse(beforeHookReturnedConfig);
  const server = new _mochaRemoteServer.Server({
    autoStart: false,
    autoRun: finalConfig.watch,
    host: finalConfig.hostname,
    port: finalConfig.port,
    reporter: finalConfig.reporter,
    reporterOptions: finalConfig.reporterOptions,
    // Intentionally passing full config as context.
    context: finalConfig,
    grep: finalConfig.grep,
    invert: finalConfig.invert,
    timeout: finalConfig.timeout,
    slow: finalConfig.slow
  });
  return startServer(server, finalConfig, target.after).then(() => {
    if (finalConfig.coverage) {
      attachHttpServer(server.wss);
    }
    if (!finalConfig.watch) {
      server.run(async failures => {
        global.__coverage__ = coverageMap.toJSON();
        await cleanup();
        process.exit(failures > 0 ? 1 : 0);
      });
    }
  });
}).help(true).alias('h', 'help').argv;
//# sourceMappingURL=cli.js.map